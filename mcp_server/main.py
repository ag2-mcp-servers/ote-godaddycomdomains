# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T08:11:32+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Header, Path, Query
from pydantic import conint

from models import (
    Action,
    ArrayOfDNSRecord,
    CheckType,
    Country,
    DomainAvailableBulk,
    DomainAvailableBulkMixed,
    DomainAvailableResponse,
    DomainContacts,
    DomainDetail,
    DomainDetailV2,
    DomainForwardingCreate,
    DomainNotification,
    DomainPurchase,
    DomainPurchaseResponse,
    DomainRedeemV2,
    DomainRenew,
    DomainsContactsBulk,
    DomainTransferIn,
    DomainUpdate,
    Error,
    ErrorDomainContactsValidate,
    ErrorLimit,
    Includes,
    Includes1,
    JsonSchema,
    Maintenance,
    MaintenanceDetail,
    PrivacyPurchase,
    Sources,
    Status10,
    Statuses,
    StatusGroups,
    Tlds,
    Type9,
    Type10,
    Type11,
    Type15,
    Type16,
    Type17,
    Types,
    V1DomainsAgreementsGetResponse,
    V1DomainsAvailablePostRequest,
    V1DomainsDomainRecordsPutRequest,
    V1DomainsDomainRecordsTypeNameGetResponse,
    V1DomainsDomainRecordsTypeNamePutRequest,
    V1DomainsDomainRecordsTypePutRequest,
    V1DomainsGetResponse,
    V1DomainsSuggestGetResponse,
    V1DomainsTldsGetResponse,
    V2CustomersCustomerIdDomainsDomainActionsGetResponse,
    V2CustomersCustomerIdDomainsForwardsFqdnGetResponse,
    V2CustomersCustomerIdDomainsNotificationsOptInGetResponse,
)

app = MCPProxy(
    title='',
    version='1.0.0',
    servers=[{'url': '//api.ote-godaddy.com'}],
)


@app.get(
    '/v1/domains', tags=['domain_listing_operations', 'comprehensive_domain_management']
)
def list(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    statuses: Optional[Statuses] = None,
    status_groups: Optional[StatusGroups] = Query(None, alias='statusGroups'),
    limit: Optional[conint(ge=1, le=1000)] = None,
    marker: Optional[str] = None,
    includes: Optional[Includes] = None,
    modified_date: Optional[str] = Query(None, alias='modifiedDate'),
):
    """
    Retrieve a list of Domains for the specified Shopper
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/domains/agreements',
    tags=[
        'domain_purchase_operations',
        'tld_retrieval_management',
        'domain_privacy_services',
    ],
)
def get_agreement(
    x__market__id: Optional[str] = Header('en-US', alias='X-Market-Id'),
    tlds: Tlds = ...,
    privacy: bool = ...,
    for_transfer: Optional[bool] = Query(None, alias='forTransfer'),
):
    """
    Retrieve the legal agreement(s) required to purchase the specified TLD and add-ons
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/domains/available',
    tags=['domain_availability_check', 'comprehensive_domain_management'],
)
def available(
    domain: str,
    check_type: Optional[CheckType] = Query('FAST', alias='checkType'),
    for_transfer: Optional[bool] = Query(False, alias='forTransfer'),
):
    """
    Determine whether or not the specified domain is available for purchase
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/domains/available',
    tags=['domain_availability_check', 'comprehensive_domain_management'],
)
def available_bulk(
    check_type: Optional[CheckType] = Query('FAST', alias='checkType'),
    body: V1DomainsAvailablePostRequest = ...,
):
    """
    Determine whether or not the specified domains are available for purchase
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/domains/contacts/validate',
    description=""" All contacts specified in request will be validated against all domains specifed in "domains". As an alternative, you can also pass in tlds, with the exception of `uk`, which requires full domain names """,
    tags=['domain_schema_verification', 'domain_contact_info_management'],
)
def contacts_validate(
    x__private__label__id: Optional[int] = Header(1, alias='X-Private-Label-Id'),
    market_id: Optional[str] = Query('en-US', alias='marketId'),
    body: DomainsContactsBulk = ...,
):
    """
    Validate the request body using the Domain Contact Validation Schema for specified domains.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/domains/purchase',
    tags=['domain_purchase_operations', 'comprehensive_domain_management'],
)
def purchase(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    body: DomainPurchase = ...,
):
    """
    Purchase and register the specified Domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/domains/purchase/schema/{tld}',
    tags=['domain_schema_verification', 'tld_retrieval_management'],
)
def schema(tld: str):
    """
    Retrieve the schema to be submitted when registering a Domain for the specified TLD
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/domains/purchase/validate',
    tags=['domain_schema_verification', 'domain_purchase_operations'],
)
def validate(body: DomainPurchase):
    """
    Validate the request body using the Domain Purchase Schema for the specified TLD
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/v1/domains/suggest', tags=['domain_name_suggestions'])
def suggest(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    query: Optional[str] = None,
    country: Optional[Country] = None,
    city: Optional[str] = None,
    sources: Optional[Sources] = None,
    tlds: Optional[Tlds] = None,
    length_max: Optional[int] = Query(None, alias='lengthMax'),
    length_min: Optional[int] = Query(None, alias='lengthMin'),
    limit: Optional[int] = None,
    wait_ms: Optional[int] = Query(1000, alias='waitMs'),
):
    """
    Suggest alternate Domain names based on a seed Domain, a set of keywords, or the shopper's purchase history
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/domains/tlds', tags=['tld_retrieval_management', 'domain_listing_operations']
)
def tlds():
    """
    Retrieves a list of TLDs supported and enabled for sale
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/domains/{domain}',
    tags=['domain_purchase_operations', 'comprehensive_domain_management'],
)
def cancel(domain: str):
    """
    Cancel a purchased domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/domains/{domain}',
    tags=['domain_listing_operations', 'comprehensive_domain_management'],
)
def get(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    domain: str = ...,
):
    """
    Retrieve details for the specified Domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/domains/{domain}',
    tags=['domain_contact_info_management', 'comprehensive_domain_management'],
)
def update(
    domain: str,
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    body: DomainUpdate = ...,
):
    """
    Update details for the specified Domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/domains/{domain}/contacts',
    tags=['domain_contact_info_management', 'comprehensive_domain_management'],
)
def update_contacts(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    domain: str = ...,
    body: DomainContacts = ...,
):
    """
    Update domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/domains/{domain}/privacy',
    tags=['domain_privacy_services', 'domain_purchase_operations'],
)
def cancel_privacy(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    domain: str = ...,
):
    """
    Submit a privacy cancellation request for the given domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/domains/{domain}/privacy/purchase',
    tags=['domain_privacy_services', 'domain_purchase_operations'],
)
def purchase_privacy(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    domain: str = ...,
    body: PrivacyPurchase = ...,
):
    """
    Purchase privacy for a specified domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/domains/{domain}/records',
    tags=['dns_record_management', 'comprehensive_domain_management'],
)
def record_add(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    domain: str = ...,
    body: ArrayOfDNSRecord = ...,
):
    """
    Add the specified DNS Records to the specified Domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/domains/{domain}/records',
    tags=['dns_record_management', 'comprehensive_domain_management'],
)
def record_replace(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    domain: str = ...,
    body: V1DomainsDomainRecordsPutRequest = ...,
):
    """
    Replace all DNS Records for the specified Domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/v1/domains/{domain}/records/{type}', tags=['dns_record_management'])
def record_replace_type(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    domain: str = ...,
    type: Type9 = ...,
    body: V1DomainsDomainRecordsTypePutRequest = ...,
):
    """
    Replace all DNS Records for the specified Domain with the specified Type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/domains/{domain}/records/{type}/{name}', tags=['dns_record_management']
)
def record_delete_type_name(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    domain: str = ...,
    type: Type10 = ...,
    name: str = ...,
):
    """
    Delete all DNS Records for the specified Domain with the specified Type and Name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/domains/{domain}/records/{type}/{name}',
    tags=[
        'dns_record_management',
        'domain_listing_operations',
        'comprehensive_domain_management',
    ],
)
def record_get(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    domain: str = ...,
    type: Type11 = ...,
    name: str = ...,
    offset: Optional[int] = None,
    limit: Optional[int] = None,
):
    """
    Retrieve DNS Records for the specified Domain, optionally with the specified Type and/or Name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/domains/{domain}/records/{type}/{name}',
    tags=['dns_record_management', 'comprehensive_domain_management'],
)
def record_replace_type_name(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    domain: str = ...,
    type: Type11 = ...,
    name: str = ...,
    body: V1DomainsDomainRecordsTypeNamePutRequest = ...,
):
    """
    Replace all DNS Records for the specified Domain with the specified Type and Name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/domains/{domain}/renew',
    tags=['domain_purchase_operations', 'comprehensive_domain_management'],
)
def renew(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    domain: str = ...,
    body: DomainRenew = None,
):
    """
    Renew the specified Domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/domains/{domain}/transfer',
    tags=[
        'domain_transfer_operations',
        'domain_purchase_operations',
        'comprehensive_domain_management',
    ],
)
def transfer_in(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    domain: str = ...,
    body: DomainTransferIn = ...,
):
    """
    Purchase and start or restart transfer process
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/domains/{domain}/verifyRegistrantEmail',
    tags=['domain_contact_info_management', 'comprehensive_domain_management'],
)
def verify_email(
    x__shopper__id: Optional[str] = Header(None, alias='X-Shopper-Id'),
    domain: str = ...,
):
    """
    Re-send Contact E-mail Verification for specified Domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/customers/{customerId}/domains/forwards/{fqdn}',
    description=""" <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul> """,
    tags=[
        'domain_forwarding_settings',
        'domain_purchase_operations',
        'comprehensive_domain_management',
    ],
)
def domains_forwards_delete(
    customer_id: str = Path(..., alias='customerId'), fqdn: str = ...
):
    """
    Submit a forwarding cancellation request for the given fqdn
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customers/{customerId}/domains/forwards/{fqdn}',
    description=""" <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul> """,
    tags=['domain_forwarding_settings', 'comprehensive_domain_management'],
)
def domains_forwards_get(
    customer_id: str = Path(..., alias='customerId'),
    fqdn: str = ...,
    include_subs: Optional[bool] = Query(None, alias='includeSubs'),
):
    """
    Retrieve the forwarding information for the given fqdn
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/customers/{customerId}/domains/forwards/{fqdn}',
    description=""" <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul> """,
    tags=['domain_forwarding_settings'],
)
def domains_forwards_post(
    customer_id: str = Path(..., alias='customerId'),
    fqdn: str = ...,
    body: DomainForwardingCreate = ...,
):
    """
    Create a new forwarding configuration for the given FQDN
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/customers/{customerId}/domains/forwards/{fqdn}',
    description=""" <strong>Notes:</strong><ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul> """,
    tags=['domain_forwarding_settings', 'comprehensive_domain_management'],
)
def domains_forwards_put(
    customer_id: str = Path(..., alias='customerId'),
    fqdn: str = ...,
    body: DomainForwardingCreate = ...,
):
    """
    Modify the forwarding information for the given fqdn
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customers/{customerId}/domains/notifications', tags=['notification_handling']
)
def get_v2_customers__customer_id_domains_notifications(
    x__request__id: Optional[str] = Header(None, alias='X-Request-Id'),
    customer_id: str = Path(..., alias='customerId'),
):
    """
    Retrieve the next domain notification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customers/{customerId}/domains/notifications/optIn',
    tags=['notification_handling'],
)
def get_v2_customers__customer_id_domains_notifications_opt_in(
    x__request__id: Optional[str] = Header(None, alias='X-Request-Id'),
    customer_id: str = Path(..., alias='customerId'),
):
    """
    Retrieve a list of notification types that are opted in
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/customers/{customerId}/domains/notifications/optIn',
    tags=['notification_handling'],
)
def put_v2_customers__customer_id_domains_notifications_opt_in(
    x__request__id: Optional[str] = Header(None, alias='X-Request-Id'),
    customer_id: str = Path(..., alias='customerId'),
    types: Types = ...,
):
    """
    Opt in to recieve notifications for the submitted notification types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customers/{customerId}/domains/notifications/schemas/{type}',
    tags=['notification_handling'],
)
def retrieve_notification_schema_by_type(
    x__request__id: Optional[str] = Header(None, alias='X-Request-Id'),
    customer_id: str = Path(..., alias='customerId'),
    type: Type15 = ...,
):
    """
    Retrieve the schema for the notification data for the specified notification type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/customers/{customerId}/domains/notifications/{notificationId}/acknowledge',
    tags=['notification_handling'],
)
def acknowledge_domain_notification(
    x__request__id: Optional[str] = Header(None, alias='X-Request-Id'),
    customer_id: str = Path(..., alias='customerId'),
    notification_id: str = Path(..., alias='notificationId'),
):
    """
    Acknowledge a domain notification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customers/{customerId}/domains/{domain}',
    tags=['domain_listing_operations', 'comprehensive_domain_management'],
)
def get_v2_customers__customer_id_domains__domain(
    x__request__id: Optional[str] = Header(None, alias='X-Request-Id'),
    customer_id: str = Path(..., alias='customerId'),
    domain: str = ...,
    includes: Optional[Includes1] = None,
):
    """
    Retrieve details for the specified Domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customers/{customerId}/domains/{domain}/actions',
    tags=['domain_listing_operations', 'comprehensive_domain_management'],
)
def get_v2_customers__customer_id_domains__domain_actions(
    x__request__id: Optional[str] = Header(None, alias='X-Request-Id'),
    customer_id: str = Path(..., alias='customerId'),
    domain: str = ...,
):
    """
    Retrieves a list of the most recent actions for the specified domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/customers/{customerId}/domains/{domain}/actions/{type}',
    tags=['domain_purchase_operations', 'comprehensive_domain_management'],
)
def delete_v2_customers__customer_id_domains__domain_actions__type(
    x__request__id: Optional[str] = Header(None, alias='X-Request-Id'),
    customer_id: str = Path(..., alias='customerId'),
    domain: str = ...,
    type: Type16 = ...,
):
    """
    Cancel the most recent user action for the specified domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/customers/{customerId}/domains/{domain}/actions/{type}',
    tags=['domain_listing_operations', 'comprehensive_domain_management'],
)
def get_v2_customers__customer_id_domains__domain_actions__type(
    x__request__id: Optional[str] = Header(None, alias='X-Request-Id'),
    customer_id: str = Path(..., alias='customerId'),
    domain: str = ...,
    type: Type17 = ...,
):
    """
    Retrieves the most recent action for the specified domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/customers/{customerId}/domains/{domain}/redeem',
    tags=['domain_purchase_operations', 'comprehensive_domain_management'],
)
def post_v2_customers__customer_id_domains__domain_redeem(
    x__request__id: Optional[str] = Header(None, alias='X-Request-Id'),
    customer_id: str = Path(..., alias='customerId'),
    domain: str = ...,
    body: DomainRedeemV2 = None,
):
    """
    Purchase a restore for the given domain to bring it out of redemption
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/customers/{customerId}/domains/{domain}/transferOut',
    tags=['domain_transfer_operations', 'comprehensive_domain_management'],
)
def post_v2_customers__customer_id_domains__domain_transfer_out(
    x__request__id: Optional[str] = Header(None, alias='X-Request-Id'),
    customer_id: str = Path(..., alias='customerId'),
    domain: str = ...,
    registrar: str = ...,
):
    """
    Initiate transfer out to another registrar for a .uk domain.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/v2/domains/maintenances', tags=['system_maintenance_info'])
def get_v2_domains_maintenances(
    x__request__id: Optional[str] = Header(None, alias='X-Request-Id'),
    status: Optional[Status10] = None,
    modified_at_after: Optional[str] = Query(None, alias='modifiedAtAfter'),
    starts_at_after: Optional[str] = Query(None, alias='startsAtAfter'),
    limit: Optional[conint(ge=1, le=100)] = 100,
):
    """
    Retrieve a list of upcoming system Maintenances
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/v2/domains/maintenances/{maintenanceId}', tags=['system_maintenance_info'])
def get_v2_domains_maintenances__maintenance_id(
    x__request__id: Optional[str] = Header(None, alias='X-Request-Id'),
    maintenance_id: str = Path(..., alias='maintenanceId'),
):
    """
    Retrieve the details for an upcoming system Maintenances
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
